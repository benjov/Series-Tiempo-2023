#install.packages("dynlm")
#install.packages("moments")
#install.packages("broom")
#install.packages("FinTS")
#install.packages('rugarch')
#install.packages("tsbox")
#install.packages("metRology")
#install.packages("expm")
#install.packages("MTS")
#install.packages("rmgarch")
#install.packages("Rcpp")
library(expm)
library(Matrix)
library(ggplot2)
library(quantmod)
library(moments)
library(dynlm)
library(broom)
library(FinTS)
library(lubridate)
library(forecast)
library(readxl)
library(MASS)
library(rugarch)
library(tsbox)
library(MTS)
library(rmgarch)
library(Rcpp)
options("getSymbols.warning4.0"=FALSE)
BTC <-getSymbols("BTC-USD", src = "yahoo", auto.assign = FALSE)
View(BTC)
BTC <- na.omit(BTC)
chartSeries(BTC,TA='addBBands();
addBBands(draw="p");
addVo();
addMACD()',
subset='2021',
theme="white")
head(BTC)
options("getSymbols.warning4.0"=FALSE)
BTC <-getSymbols("BTC-USD", src = "yahoo", auto.assign = FALSE)
BTC <- na.omit(BTC)
chartSeries(BTC,TA='addBBands();
addBBands(draw="p");
addVo();
addMACD()',
subset='2021',
theme="white")
head(BTC)
plot(BTC$`BTC-USD.Adjusted`)
logret <- ts(diff(log(BTC$`BTC-USD.Adjusted`))[-1])
plot(logret)
alpha <- 0.05
VaR <- quantile(logret, alpha)
VaR
round(VaR, 4)
round(VaR, 4)*100
qplot(logret , geom = 'histogram') + geom_histogram(fill = 'lightblue' , bins = 30) +
geom_histogram(aes(logret[logret < quantile(logret , 0.05)]) , fill = 'red' , bins = 30) +
labs(x = 'Daily Returns')
qplot(logret , geom = 'histogram') + geom_histogram(fill = 'lightblue' , bins = 10) +
geom_histogram(aes(logret[logret < quantile(logret , 0.05)]) , fill = 'red' , bins = 10) +
labs(x = 'Daily Returns')
qplot(logret , geom = 'histogram') + geom_histogram(fill = 'lightblue' , bins = 100) +
geom_histogram(aes(logret[logret < quantile(logret , 0.05)]) , fill = 'red' , bins = 100) +
labs(x = 'Daily Returns')
qplot(logret , geom = 'histogram') + geom_histogram(fill = 'lightblue' , bins = 30) +
geom_histogram(aes(logret[logret < quantile(logret , 0.05)]) , fill = 'red' , bins = 30) +
labs(x = 'Daily Returns')
?rnorm
normal_dist <- rnorm(100000, mean(logret), sd(logret))
VaR_n <- quantile(normal_dist, 0.05)
ES_n <- mean(normal_dist[normal_dist<VaR])
ggplot()+
geom_density(aes(logret, geom ='density', col = 'returns'))+
geom_density(aes(normal_dist, col = 'normal'))
vector_ret <- as.vector(logret)
##Kurtosis
round(kurtosis(vector_ret),2)
##Sesgo
round(skewness(vector_ret),2)
##Prueba de normalidad
jarque.test(vector_ret)
#install.packages("dynlm")
#install.packages("moments")
#install.packages("broom")
#install.packages("FinTS")
#install.packages('rugarch')
#install.packages("tsbox")
#install.packages("metRology")
#install.packages("expm")
#install.packages("MTS")
#install.packages("rmgarch")
#install.packages("Rcpp")
library(expm)
library(Matrix)
library(ggplot2)
library(quantmod)
library(moments)
library(dynlm)
library(broom)
library(FinTS)
library(lubridate)
library(forecast)
library(readxl)
library(MASS)
library(rugarch)
library(tsbox)
library(MTS)
library(rmgarch)
library(Rcpp)
#install.packages("dynlm")
#install.packages("moments")
#install.packages("broom")
#install.packages("FinTS")
#install.packages('rugarch')
#install.packages("tsbox")
#install.packages("metRology")
#install.packages("expm")
#install.packages("MTS")
#install.packages("rmgarch")
#install.packages("Rcpp")
library(expm)
library(Matrix)
library(ggplot2)
library(quantmod)
library(moments)
library(dynlm)
library(broom)
library(FinTS)
library(lubridate)
library(forecast)
library(readxl)
library(MASS)
library(rugarch)
library(tsbox)
library(MTS)
library(rmgarch)
library(Rcpp)
options("getSymbols.warning4.0"=FALSE)
BTC <-getSymbols("BTC-USD", src = "yahoo", auto.assign = FALSE)
BTC <- na.omit(BTC)
chartSeries(BTC,TA='addBBands();
addBBands(draw="p");
addVo();
addMACD()',
subset='2021',
theme="white")
head(BTC)
plot(BTC$`BTC-USD.Adjusted`)
logret <- ts(diff(log(BTC$`BTC-USD.Adjusted`))[-1])
plot(logret)
alpha <- 0.05
VaR <- quantile(logret, alpha)
round(VaR, 4)*100
qplot(logret , geom = 'histogram') + geom_histogram(fill = 'lightblue' , bins = 30) +
geom_histogram(aes(logret[logret < quantile(logret , 0.05)]) , fill = 'red' , bins = 30) +
labs(x = 'Daily Returns')
normal_dist <- rnorm(100000, mean(logret), sd(logret))
VaR_n <- quantile(normal_dist, 0.05)
ES_n <- mean(normal_dist[normal_dist<VaR])
ggplot()+
geom_density(aes(logret, geom ='density', col = 'returns'))+
geom_density(aes(normal_dist, col = 'normal'))
vector_ret <- as.vector(logret)
##Kurtosis
round(kurtosis(vector_ret),2)
##Sesgo
round(skewness(vector_ret),2)
##Prueba de normalidad
jarque.test(vector_ret)
plot(logret)
acf(logret)
acf(abs(logret))
sample(as.vector(logret), size =  length(logret), replace = FALSE)
sample(as.vector(logret), size =  length(logret), replace = FALSE)
sample(as.vector(logret), size =  length(logret), replace = FALSE)
sample(as.vector(logret), size =  length(logret), replace = FALSE)
?sample
logret_random <- sample(as.vector(logret), size =  length(logret), replace = FALSE)
acf(abs(logret_random))
par(mfrow = c(1,2))
plot(logret)
plot(logret_random, type = 'l')
?dynlm
logret_mean = dynlm(logret~1)
summary(logret_mean)
ehatsq = ts(resid(logret_mean)^2)
ARCH_m = dynlm(ehatsq~L(ehatsq))
summary(ARCH_m)
acf(ARCH_m$residuals)
acf(abs(ARCH_m$residuals))
ArchTest(logret, lags = 1, demean = TRUE)
logret_mean = dynlm(logret~1)
summary(logret_mean)
ehatsq = ts(resid(logret_mean)^2)
ARCH_m = dynlm(ehatsq~L(ehatsq))
summary(ARCH_m)
acf(ARCH_m$residuals)
acf(abs(ARCH_m$residuals))
ArchTest(logret, lags = 1, demean = TRUE)
library(rugarch)
auto.arima(logret)
?ugarchspec
model.spec = ugarchspec( variance.model = list(model = 'sGARCH' , garchOrder = c(1, 0)),
mean.model = list(armaOrder = c(2,0)), distribution.model = "std")
?ugarchfit
arch.fit = ugarchfit(spec = model.spec , data = logret, solver = 'solnp')
arch.fit@fit$matcoef
boot.garch <- ugarchboot(arch.fit,
method = "Partial",
sampling = "raw",  #bootstrap from fitted varepsilon
n.ahead = 1,          #simulation horizon
n.bootpred = 100000, #number of simulations
solver = "solnp")
## VaR estimado mediante ARCH
rvec <- boot.garch@fseries
alpha <- 0.05
VaR <- quantile(rvec, alpha)
round(VaR,6)
F_inv = qt(0.05, t.fit$estimate[3])
tiempo= time(BTC[-1])
F_inv = qt(0.05, arch.fit$estimate[3])
?ugarchboot
boot.garch
## VaR estimado mediante ARCH
rvec <- boot.garch@fseries
alpha <- 0.05
VaR <- quantile(rvec, alpha)
round(VaR,6)
F_inv = qt(0.05, t.fit$estimate[3])
tiempo= time(BTC[-1])
ggplot()+
geom_point(aes(y = logret,x = tiempo),colour = 'lightgrey' , size = 2) +
geom_line(aes(y = arch.fit@fit$sigma*(F_inv), x = tiempo), colour = 'red') +
geom_hline(yintercept = sd(logret)*qnorm(0.05) , colour = 'darkgreen' , size = 1.2) + theme_light() +
labs(x = '' , y = 'Daily Returns' , title = 'Value at Risk Comparison')
F_inv = qt(0.05, arch.fit@fit$estimate[3])
boot.garch
arch.fit@fit$matcoef
model.spec = ugarchspec(variance.model = list(model = 'sGARCH' , garchOrder = c(0,1)),
mean.model = list(armaOrder = c(2,0)), distribution.model = "std")
fit.garch.n = ugarchfit(spec = model.spec, data = logret, solver = "solnp")
fit.garch.n = ugarchfit(spec = model.spec, data = logret, solver = "solnp")
fit.garch.n@fit$matcoef
boot.garch <- ugarchboot(fit.garch.n,
method = "Partial",
sampling = "raw",  #bootstrap from fitted varepsilon
n.ahead = 1,          #simulation horizon
n.bootpred = 100000, #number of simulations
solver = "solnp")
boot.garch
fit.garch.n@fit$matcoef
infocriteria(fit.garch.n)
source("Lag_Opt_GARCH.R")
Lag_Opt_GARCH(ehatsq,4,4)
model.spec = ugarchspec(variance.model = list(model = 'sGARCH' , garchOrder = c(4,3)),
mean.model = list(armaOrder = c(2,0)), distribution.model = "std")
model.fit = ugarchfit(spec = model.spec , data = logret, solver = 'solnp')
model.fit = ugarchfit(spec = model.spec , data = logret, solver = 'solnp')
model.fit@fit$matcoef
boot.garch <- ugarchboot(model.fit,
method = "Partial",
sampling = "raw",  #bootstrap from fitted varepsilon
n.ahead = 1,          #simulation horizon
n.bootpred = 100000, #number of simulations
solver = "solnp")
boot.garch
model.spec = ugarchspec(variance.model = list(model = 'sGARCH' , garchOrder = c(1,1)),
mean.model = list(armaOrder = c(4,2)), distribution.model = "std")
model.fit = ugarchfit(spec = model.spec , data = logret, solver = 'solnp')
model.fit = ugarchfit(spec = model.spec , data = logret, solver = 'solnp')
spec = getspec(model.fit)
setfixed(spec) <- as.list(coef(model.fit))
forecast = ugarchforecast(spec, n.ahead = 12, n.roll = 0, logret)
sigma(forecast)
fitted(forecast)
forecast
#install.packages("dynlm")
#install.packages("moments")
#install.packages("broom")
#install.packages("FinTS")
#install.packages('rugarch')
#install.packages("tsbox")
#install.packages("metRology")
#install.packages("expm")
#install.packages("MTS")
#install.packages("rmgarch")
#install.packages("Rcpp")
library(expm)
library(Matrix)
library(ggplot2)
library(quantmod)
library(moments)
library(dynlm)
library(broom)
library(FinTS)
library(lubridate)
library(forecast)
library(readxl)
library(MASS)
library(rugarch)
library(tsbox)
library(MTS)
library(rmgarch)
library(Rcpp)
options("getSymbols.warning4.0"=FALSE)
BTC <-getSymbols("BTC-USD", src = "yahoo", auto.assign = FALSE)
ETH <-getSymbols("ETH-USD", src = "yahoo", auto.assign = FALSE)
BNB <-getSymbols("BNB-USD", src = "yahoo", auto.assign = FALSE)
chartSeries(BTC,TA='addBBands();
addBBands(draw="p");
addVo();
addMACD()',
# subset='2021',
theme="white")
chartSeries(ETH,TA='addBBands();
addBBands(draw="p");
addVo();
addMACD()',
# subset='2021',
theme="white")
chartSeries(BNB,TA='addBBands();
addBBands(draw="p");
addVo();
addMACD()',
# subset='2021',
theme="white")
ln_BTC <- diff(log(BTC$`BTC-USD.Adjusted`))
ln_ETH <- diff(log(ETH$`ETH-USD.Adjusted`))
ln_BNB <- diff(log(BNB$`BNB-USD.Adjusted`))
r_t=cbind(ln_BTC, ln_ETH, ln_BNB)
returns = window(r_t, start = "2017-11-10")
xspec = ugarchspec(mean.model = list(armaOrder = c(1, 1)), variance.model = list(garchOrder = c(1,1), model = 'sGARCH'), distribution.model = 'norm')
uspec = multispec(replicate(3, xspec))
spec1 = dccspec(uspec = uspec, dccOrder = c(1, 1), distribution = 'mvnorm')
spec1a = dccspec(uspec = uspec, dccOrder = c(1, 1), model='aDCC', distribution = 'mvnorm')
cl = makePSOCKcluster(3)
multf = multifit(uspec, returns, cluster = cl)
fit1 = dccfit(spec1, data = returns, fit.control = list(eval.se = TRUE, scale = TRUE), fit = multf, cluster = cl)
print(fit1)
plot(fit1, which=1)
plot(fit1, which=2)
plot(fit1, which=3)
plot(fit1, which=4)
plot(fit1, which=5)
#install.packages("dynlm")
#install.packages("moments")
#install.packages("broom")
#install.packages("FinTS")
#install.packages('rugarch')
#install.packages("tsbox")
#install.packages("metRology")
#install.packages("expm")
#install.packages("MTS")
#install.packages("rmgarch")
#install.packages("Rcpp")
library(expm)
library(Matrix)
library(ggplot2)
library(quantmod)
library(moments)
library(dynlm)
library(broom)
library(FinTS)
library(lubridate)
library(forecast)
library(readxl)
library(MASS)
library(rugarch)
library(tsbox)
library(MTS)
library(rmgarch)
library(Rcpp)
options("getSymbols.warning4.0"=FALSE)
BTC <-getSymbols("BTC-USD", src = "yahoo", auto.assign = FALSE)
BTC <- na.omit(BTC)
chartSeries(BTC,TA='addBBands();
addBBands(draw="p");
addVo();
addMACD()',
subset='2021',
theme="white")
head(BTC)
View(BTC)
plot(BTC$`BTC-USD.Adjusted`)
logret <- ts(diff(log(BTC$`BTC-USD.Adjusted`))[-1])
plot(logret)
plot(logret)
acf(logret)
plot(abs(logret))
acf(abs(logret))
logret_random <- sample(as.vector(logret), size =  length(logret), replace = FALSE)
acf(abs(logret_random))
par(mfrow = c(1,2))
plot(logret)
plot(logret_random, type = 'l')
logret_mean = dynlm(logret~1)
summary(logret_mean)
ehatsq = ts(resid(logret_mean)^2)
ehatsq
ehatsq = ts(resid(logret_mean)^2)
ARCH_m = dynlm(ehatsq~L(ehatsq))
summary(ARCH_m)
logret_mean = dynlm(logret~1)
summary(logret_mean)
ehatsq = ts(resid(logret_mean)^2)
ARCH_m = dynlm(ehatsq~L(ehatsq))
summary(ARCH_m)
acf(ARCH_m$residuals)
acf(abs(ARCH_m$residuals))
ArchTest(logret, lags = 1, demean = TRUE)
ArchTest(logret, lags = 2, demean = TRUE)
ArchTest(logret, lags = 3, demean = TRUE)
ArchTest(logret, lags = 12, demean = TRUE)
logret_mean = dynlm(logret~1)
summary(logret_mean)
ehatsq = ts(resid(logret_mean)^2)
ARCH_m = dynlm(ehatsq~L(ehatsq))
summary(ARCH_m)
acf(ARCH_m$residuals)
acf(abs(ARCH_m$residuals))
ArchTest(logret, lags = 1, demean = TRUE)
library(rugarch)
auto.arima(logret)
model.spec = ugarchspec( variance.model = list(model = 'sGARCH' , garchOrder = c(1, 0)),
mean.model = list(armaOrder = c(2,0)), distribution.model = "std")
model.spec = ugarchspec( variance.model = list(model = 'sGARCH' , garchOrder = c(1, 0)),
mean.model = list(armaOrder = c(2,0)), distribution.model = "std")
arch.fit = ugarchfit(spec = model.spec , data = logret, solver = 'solnp')
arch.fit@fit$matcoef
model.spec = ugarchspec(variance.model = list(model = 'sGARCH' , garchOrder = c(0,1)),
mean.model = list(armaOrder = c(2,0)), distribution.model = "std")
fit.garch.n = ugarchfit(spec = model.spec, data = logret, solver = "solnp")
fit.garch.n = ugarchfit(spec = model.spec, data = logret, solver = "solnp")
fit.garch.n@fit$matcoef
boot.garch <- ugarchboot(arch.fit,
method = "Partial",
sampling = "raw",  #bootstrap from fitted varepsilon
n.ahead = 1,          #simulation horizon
n.bootpred = 100000, #number of simulations
solver = "solnp")
boot.garch <- ugarchboot(arch.fit,
method = "Partial",
sampling = "raw",  #bootstrap from fitted varepsilon
n.ahead = 1,          #simulation horizon
n.bootpred = 100000, #number of simulations
solver = "solnp")
boot.garch
boot.garch <- ugarchboot(fit.garch.n,
method = "Partial",
sampling = "raw",  #bootstrap from fitted varepsilon
n.ahead = 1,          #simulation horizon
n.bootpred = 100000, #number of simulations
solver = "solnp")
boot.garch <- ugarchboot(fit.garch.n,
method = "Partial",
sampling = "raw",  #bootstrap from fitted varepsilon
n.ahead = 1,          #simulation horizon
n.bootpred = 100000, #number of simulations
solver = "solnp")
boot.garch
infocriteria(fit.garch.n)
source("Lag_Opt_GARCH.R")
View(Lag_Opt_GARCH)
Lag_Opt_GARCH(ehatsq,4,4)
model.spec = ugarchspec(variance.model = list(model = 'sGARCH' , garchOrder = c(4,2)),
mean.model = list(armaOrder = c(2,0)), distribution.model = "std")
model.fit = ugarchfit(spec = model.spec , data = logret, solver = 'solnp')
model.fit = ugarchfit(spec = model.spec , data = logret, solver = 'solnp')
model.fit@fit$matcoef
model.spec = ugarchspec(variance.model = list(model = 'sGARCH' , garchOrder = c(1,1)),
mean.model = list(armaOrder = c(4,2)), distribution.model = "std")
model.fit = ugarchfit(spec = model.spec , data = logret, solver = 'solnp')
spec = getspec(model.fit)
setfixed(spec) <- as.list(coef(model.fit))
forecast = ugarchforecast(spec, n.ahead = 12, n.roll = 0, logret)
sigma(forecast)
fitted(forecast)
forecast
